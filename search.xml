<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Unlua代码分析</title>
    <url>/2024/04/14/Unlua%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>该文章主要记录本人在分析Unlua源代码所作的一些笔记，里面包含一些用到的lua语法的说明，以及动态绑定和静态绑定，并且还分析了C++和lua的互调流程。</p>
</blockquote>
<span id="more"></span>

<h1 id="lua语法"><a href="#lua语法" class="headerlink" title="lua语法"></a>lua语法</h1><h2 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h2><p>Lua的注册表可以被想象成一个全局的哈希表（或映射），键通常是字符串（如元表的名称）或者是特殊的指针或引用（对于需要唯一键的数据）。在注册表中，每个键都关联一个值，这个值可以是任何Lua支持的类型（如表、函数、用户数据等）。</p>
<h2 id="luaL-getmetatable"><a href="#luaL-getmetatable" class="headerlink" title="luaL_getmetatable"></a>luaL_getmetatable</h2><p>用于从注册表中检索一个元表。这个函数主要用于获取之前已经注册到 Lua 的全局注册表中的元表，这些元表通常是与特定的用户数据类型或类关联的。</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">luaL_getmetatable</span>(L, <span class="string">&quot;TSharedPtr&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="luaL-newmetatable"><a href="#luaL-newmetatable" class="headerlink" title="luaL_newmetatable"></a>luaL_newmetatable</h2><h2 id="lua-getmetatable"><a href="#lua-getmetatable" class="headerlink" title="lua_getmetatable"></a>lua_getmetatable</h2><h1 id="Unlua"><a href="#Unlua" class="headerlink" title="Unlua"></a>Unlua</h1><h2 id="UObject的注册以及Lua覆写函数流程"><a href="#UObject的注册以及Lua覆写函数流程" class="headerlink" title="UObject的注册以及Lua覆写函数流程"></a>UObject的注册以及Lua覆写函数流程</h2><p>UObject注册是从NotifyUObjectCreated这个函数监听Object创建开始的。注册函数bool FLuaEnv::TryBind(UObject* Object) ，判断是不是静态绑定</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bool bImplUnluaInterface = <span class="title class_">Class</span>-&gt;<span class="title class_">ImplementsInterface</span>(<span class="title class_">InterfaceClass</span>);</span><br></pre></td></tr></table></figure>
<p>看看是不是动态绑定，动态绑定的时候会通过</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> int32 <span class="title class_">UWorld</span>_SpawnActor(lua_State* L)</span><br><span class="line"><span class="keyword">static</span> int32 <span class="title class_">UWorld</span>_SpawnActorEx(lua_State* L)</span><br><span class="line"><span class="keyword">static</span> int32 <span class="title class_">Global</span>_NewObject(lua_State *L)</span><br></pre></td></tr></table></figure>
<p>上面三个函数将路径信息传递到C++这边，然后通过下面的函数记录到全局变量GLuaDynamicBinding中</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line">bValid = <span class="title class_">GLuaDynamicBinding</span>.<span class="title class_">Push</span>(<span class="title class_">Class</span>, <span class="title class_">ModuleName</span>, <span class="title class_">InitializerTableRef</span>);</span><br></pre></td></tr></table></figure>
<p>因此现在看下面的动态绑定代码就很好理解了</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!bImplUnluaInterface)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// dynamic binding</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">GLuaDynamicBinding</span>.<span class="title class_">IsValid</span>(<span class="title class_">Class</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">GetManager</span>()-&gt;<span class="title class_">Bind</span>(<span class="title class_">Object</span>, *<span class="title class_">GLuaDynamicBinding</span>.<span class="property">ModuleName</span>, <span class="title class_">GLuaDynamicBinding</span>.<span class="property">InitializerTableRef</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着往下走，动态绑定和静态绑定的绑定函数是一样的都是 GetManager()-&gt;Bind，现在继续分析Bind函数，在绑定UObject的时候会先绑定对应的Class ，首先创建对应的Matetable并进入到Name2Classes</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> auto L = <span class="title class_">Env</span>-&gt;<span class="title class_">GetMainState</span>();</span><br><span class="line"><span class="keyword">if</span> (!<span class="title class_">PushMetatable</span>(L, <span class="title class_">MetatableName</span>))</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> refactor</span></span><br><span class="line"><span class="title function_">lua_pop</span>(L, <span class="number">1</span>);</span><br><span class="line"><span class="title class_">FName</span> <span class="title class_">Key</span> = <span class="title class_">FName</span>(<span class="title class_">UTF8</span>_TO_TCHAR(<span class="title class_">MetatableName</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Name2Classes</span>.<span class="title class_">FindChecked</span>(<span class="title class_">Key</span>);</span><br></pre></td></tr></table></figure>
<p>之后试图去绑定对应的lua文件，然后就是正式的BindClass</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line">bool <span class="title class_">UUnLuaManager</span>::<span class="title class_">BindClass</span>(<span class="title class_">UClass</span>* <span class="title class_">Class</span>, <span class="keyword">const</span> <span class="title class_">FString</span>&amp; <span class="title class_">InModuleName</span>, <span class="title class_">FString</span>&amp; <span class="title class_">Error</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">check</span>(<span class="title class_">Class</span>);</span><br><span class="line">    <span class="comment">//.................</span></span><br><span class="line">    auto&amp; <span class="title class_">BindInfo</span> = <span class="title class_">Classes</span>.<span class="title class_">Add</span>(<span class="title class_">Class</span>);</span><br><span class="line">    <span class="title class_">BindInfo</span>.<span class="property">Class</span> = <span class="title class_">Class</span>;</span><br><span class="line">    <span class="title class_">BindInfo</span>.<span class="property">ModuleName</span> = <span class="title class_">InModuleName</span>;</span><br><span class="line">    <span class="title class_">BindInfo</span>.<span class="property">TableRef</span> = <span class="title class_">Ref</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">UnLua</span>::<span class="title class_">LowLevel</span>::<span class="title class_">GetFunctionNames</span>(<span class="title class_">Env</span>-&gt;<span class="title class_">GetMainState</span>(), <span class="title class_">Ref</span>, <span class="title class_">BindInfo</span>.<span class="property">LuaFunctions</span>);<span class="comment">//获取lua中的所有函数名称</span></span><br><span class="line">    <span class="title class_">ULuaFunction</span>::<span class="title class_">GetOverridableFunctions</span>(<span class="title class_">Class</span>, <span class="title class_">BindInfo</span>.<span class="property">UEFunctions</span>);<span class="comment">//获取类里面的反射函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用LuaTable里所有的函数来替换Class上对应的UFunction</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> auto&amp; <span class="title class_">LuaFuncName</span> : <span class="title class_">BindInfo</span>.<span class="property">LuaFunctions</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">UFunction</span>** <span class="title class_">Func</span> = <span class="title class_">BindInfo</span>.<span class="property">UEFunctions</span>.<span class="title class_">Find</span>(<span class="title class_">LuaFuncName</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Func</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title class_">UFunction</span>* <span class="title class_">Function</span> = *<span class="title class_">Func</span>;</span><br><span class="line">            <span class="title class_">ULuaFunction</span>::<span class="title class_">Override</span>(<span class="title class_">Function</span>, <span class="title class_">Class</span>, <span class="title class_">LuaFuncName</span>); <span class="comment">//要复写的函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.................</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到覆盖的过程就是遍历lua函数名称，然后看是否能够在反射函数中找到对应的同名函数，找到了就走重写代码 ULuaFunction::Override(Function, Class, LuaFuncName);</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title class_">FLuaOverrides</span>::<span class="title class_">Override</span>(<span class="title class_">UFunction</span>* <span class="title class_">Function</span>, <span class="title class_">UClass</span>* <span class="title class_">Class</span>, <span class="title class_">FName</span> <span class="title class_">NewName</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> auto <span class="title class_">OverridesClass</span> = <span class="title class_">GetOrAddOverridesClass</span>(<span class="title class_">Class</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title class_">ULuaFunction</span>* <span class="title class_">LuaFunction</span>;</span><br><span class="line">    <span class="title class_">UObject</span>* <span class="title class_">Outer</span>=<span class="title class_">Function</span>-&gt;<span class="title class_">GetOuter</span>();</span><br><span class="line">    <span class="keyword">const</span> auto bAddNew = <span class="title class_">Outer</span> != <span class="title class_">Class</span>; </span><br><span class="line">    <span class="keyword">if</span> (bAddNew)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> auto <span class="title class_">Exists</span> = <span class="title class_">Class</span>-&gt;<span class="title class_">FindFunctionByName</span>(<span class="title class_">NewName</span>, <span class="title class_">EIncludeSuperFlag</span>::<span class="title class_">ExcludeSuper</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Exists</span> &amp;&amp; <span class="title class_">Exists</span>-&gt;<span class="title class_">GetSuperStruct</span>() == <span class="title class_">Function</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">LuaFunction</span> = <span class="title class_">Cast</span>&lt;<span class="title class_">ULuaFunction</span>&gt;(<span class="title class_">Function</span>); <span class="comment">//已经覆写了就跳过</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">LuaFunction</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title class_">LuaFunction</span>-&gt;<span class="title class_">Initialize</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">FObjectDuplicationParameters</span> <span class="title class_">DuplicationParams</span>(<span class="title class_">Function</span>, <span class="title class_">OverridesClass</span>);</span><br><span class="line">    <span class="title class_">DuplicationParams</span>.<span class="property">InternalFlagMask</span> &amp;= ~<span class="title class_">EInternalObjectFlags</span>::<span class="title class_">Native</span>;</span><br><span class="line">    <span class="title class_">DuplicationParams</span>.<span class="property">DestName</span> = <span class="title class_">NewName</span>;</span><br><span class="line">    <span class="title class_">DuplicationParams</span>.<span class="property">DestClass</span> = <span class="title class_">ULuaFunction</span>::<span class="title class_">StaticClass</span>();</span><br><span class="line">    <span class="comment">// 拷贝一份Function</span></span><br><span class="line">    <span class="title class_">LuaFunction</span> = static_cast&lt;<span class="title class_">ULuaFunction</span>*&gt;(<span class="title class_">StaticDuplicateObjectEx</span>(<span class="title class_">DuplicationParams</span>));</span><br><span class="line">    <span class="comment">// 加入到OverridesClass的Children 链接中去</span></span><br><span class="line">    <span class="title class_">LuaFunction</span>-&gt;<span class="title class_">Next</span> = <span class="title class_">OverridesClass</span>-&gt;<span class="title class_">Children</span>;</span><br><span class="line">    <span class="title class_">OverridesClass</span>-&gt;<span class="title class_">Children</span> = <span class="title class_">LuaFunction</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">LuaFunction</span>-&gt;<span class="title class_">StaticLink</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="title class_">LuaFunction</span>-&gt;<span class="title class_">Initialize</span>(); <span class="comment">//一些初始化的操作</span></span><br><span class="line">    <span class="title class_">LuaFunction</span>-&gt;<span class="title class_">Override</span>(<span class="title class_">Function</span>, <span class="title class_">Class</span>, bAddNew); <span class="comment">// 真正的覆写的位置</span></span><br><span class="line">    <span class="title class_">LuaFunction</span>-&gt;<span class="title class_">Bind</span>();</span><br><span class="line">    <span class="comment">//防止GC</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Class</span>-&gt;<span class="title class_">IsRooted</span>() || <span class="title class_">GUObjectArray</span>.<span class="title class_">IsDisregardForGC</span>(<span class="title class_">Class</span>))</span><br><span class="line">        <span class="title class_">LuaFunction</span>-&gt;<span class="title class_">AddToRoot</span>(); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="title class_">LuaFunction</span>-&gt;<span class="title class_">AddToCluster</span>(<span class="title class_">Class</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数需要注意const auto bAddNew &#x3D; Outer !&#x3D; Class; 当重写的函数是蓝图函数的时候bAddNew的值就是false，当重写的函数的C++函数的时候bAddNew就是true，这里主要是判断该重写的函数是否被蓝图重写，这个在下面的步骤会用到。</p>
<p>接着走到void ULuaFunction::Override(UFunction* Function, UClass* Class, bool bAddNew)</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line">    <span class="title function_">check</span>(<span class="title class_">Function</span> &amp;&amp; <span class="title class_">Class</span> &amp;&amp; !<span class="title class_">From</span>.<span class="title class_">IsValid</span>());</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> <span class="variable constant_">WITH_METADATA</span></span><br><span class="line">    <span class="title class_">UMetaData</span>::<span class="title class_">CopyMetadata</span>(<span class="title class_">Function</span>, <span class="variable language_">this</span>);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    bActivated = <span class="literal">false</span>;</span><br><span class="line">    bAdded = bAddNew;</span><br><span class="line">    <span class="title class_">From</span> = <span class="title class_">Function</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Function</span>-&gt;<span class="title class_">GetNativeFunc</span>() == execScriptCallLua) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 目标UFunction可能已经被覆写过了</span></span><br><span class="line">        <span class="keyword">const</span> auto <span class="title class_">LuaFunction</span> = <span class="title class_">Get</span>(<span class="title class_">Function</span>);</span><br><span class="line">        <span class="title class_">Overridden</span> = <span class="title class_">LuaFunction</span>-&gt;<span class="title class_">GetOverridden</span>();</span><br><span class="line">        <span class="title function_">check</span>(<span class="title class_">Overridden</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> auto <span class="title class_">DestName</span> = <span class="title class_">FString</span>::<span class="title class_">Printf</span>(<span class="title function_">TEXT</span>(<span class="string">&quot;%s__Overridden&quot;</span>), *<span class="title class_">Function</span>-&gt;<span class="title class_">GetName</span>());</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Function</span>-&gt;<span class="title class_">HasAnyFunctionFlags</span>(FUNC_Native)) <span class="comment">//判断是不是C++函数，C++函数的则将这个函数加入到类中</span></span><br><span class="line">            <span class="title class_">GetOuterUClass</span>()-&gt;<span class="title class_">AddNativeFunction</span>(*<span class="title class_">DestName</span>, *<span class="title class_">Function</span>-&gt;<span class="title class_">GetNativeFunc</span>());</span><br><span class="line">        <span class="title class_">Overridden</span> = static_cast&lt;<span class="title class_">UFunction</span>*&gt;(<span class="title class_">StaticDuplicateObject</span>(<span class="title class_">Function</span>, <span class="title class_">GetOuter</span>(), *<span class="title class_">DestName</span>));</span><br><span class="line">        <span class="title class_">Overridden</span>-&gt;<span class="title class_">ClearInternalFlags</span>(<span class="title class_">EInternalObjectFlags</span>::<span class="title class_">Native</span>);</span><br><span class="line">        <span class="title class_">Overridden</span>-&gt;<span class="title class_">StaticLink</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="title class_">Overridden</span>-&gt;<span class="title class_">SetNativeFunc</span>(<span class="title class_">Function</span>-&gt;<span class="title class_">GetNativeFunc</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">SetActive</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>然后就是拷贝一份添加__Overridden存储在LuaFunction中的Overridden 变量中，以便恢复，最后的绑定则在SetActive函数里面</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bAdded)  <span class="comment">//这就用到前面的额值bAddNew，表示C++函数就绑定execCallLua</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">check</span>(!<span class="title class_">Class</span>-&gt;<span class="title class_">FindFunctionByName</span>(<span class="title class_">GetFName</span>(), <span class="title class_">EIncludeSuperFlag</span>::<span class="title class_">ExcludeSuper</span>));</span><br><span class="line">    <span class="title class_">SetSuperStruct</span>(<span class="title class_">Function</span>);</span><br><span class="line">    <span class="title class_">FunctionFlags</span> |= FUNC_Native;</span><br><span class="line">    <span class="title class_">ClearInternalFlags</span>(<span class="title class_">EInternalObjectFlags</span>::<span class="title class_">Native</span>);</span><br><span class="line">    <span class="title class_">SetNativeFunc</span>(execCallLua);</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Class</span>-&gt;<span class="title class_">AddFunctionToFunctionMap</span>(<span class="variable language_">this</span>, *<span class="title class_">GetName</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Function</span>-&gt;<span class="title class_">HasAnyFunctionFlags</span>(FUNC_Native))</span><br><span class="line">        <span class="title class_">Class</span>-&gt;<span class="title class_">AddNativeFunction</span>(*<span class="title class_">GetName</span>(), &amp;<span class="title class_">ULuaFunction</span>::execCallLua);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">SetSuperStruct</span>(<span class="title class_">Function</span>-&gt;<span class="title class_">GetSuperStruct</span>());</span><br><span class="line">    <span class="title class_">Script</span> = <span class="title class_">Function</span>-&gt;<span class="title class_">Script</span>;</span><br><span class="line">    <span class="title class_">Children</span> = <span class="title class_">Function</span>-&gt;<span class="title class_">Children</span>;</span><br><span class="line">    <span class="title class_">ChildProperties</span> = <span class="title class_">Function</span>-&gt;<span class="title class_">ChildProperties</span>;</span><br><span class="line">    <span class="title class_">PropertyLink</span> = <span class="title class_">Function</span>-&gt;<span class="title class_">PropertyLink</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Function</span>-&gt;<span class="title class_">FunctionFlags</span> |= FUNC_Native;</span><br><span class="line">    <span class="title class_">Function</span>-&gt;<span class="title class_">SetNativeFunc</span>(&amp;execScriptCallLua);</span><br><span class="line">    <span class="title class_">Function</span>-&gt;<span class="title class_">GetOuterUClass</span>()-&gt;<span class="title class_">AddNativeFunction</span>(*<span class="title class_">Function</span>-&gt;<span class="title class_">GetName</span>(), &amp;execScriptCallLua);</span><br><span class="line">    <span class="title class_">Function</span>-&gt;<span class="title class_">Script</span>.<span class="title class_">Empty</span>();</span><br><span class="line">    <span class="title class_">Function</span>-&gt;<span class="title class_">Script</span>.<span class="title class_">AddUninitialized</span>(<span class="title class_">ScriptMagicHeaderSize</span> + <span class="title function_">sizeof</span>(<span class="title class_">ULuaFunction</span>*));</span><br><span class="line">    <span class="keyword">const</span> auto <span class="title class_">Data</span> = <span class="title class_">Function</span>-&gt;<span class="title class_">Script</span>.<span class="title class_">GetData</span>();</span><br><span class="line">    <span class="title class_">FPlatformMemory</span>::<span class="title class_">Memcpy</span>(<span class="title class_">Data</span>, <span class="title class_">ScriptMagicHeader</span>, <span class="title class_">ScriptMagicHeaderSize</span>);</span><br><span class="line">    <span class="title class_">FPlatformMemory</span>::<span class="title class_">WriteUnaligned</span>&lt;<span class="title class_">ULuaFunction</span>*&gt;(<span class="title class_">Data</span> + <span class="title class_">ScriptMagicHeaderSize</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，当覆盖的是C++的函数时候往FuncMap中添加LuaFunction，当是蓝图函数的时候就直接拿传递进来的Function改造将NativeFunc设置成execScriptCallLua</p>
<h2 id="C-调用被Lua覆写的C-或者蓝图函数"><a href="#C-调用被Lua覆写的C-或者蓝图函数" class="headerlink" title="C++调用被Lua覆写的C++或者蓝图函数"></a>C++调用被Lua覆写的C++或者蓝图函数</h2><p>比如当我们调用下面的函数的时候：</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">UFUNCTION</span>(<span class="title class_">BlueprintNativeEvent</span>,<span class="title class_">BlueprintCallable</span>)</span><br><span class="line"><span class="keyword">void</span> <span class="title class_">SpawnText</span>();</span><br><span class="line"><span class="keyword">void</span> <span class="title class_">UTPSGameInstance</span>::<span class="title class_">SpawnText</span>_Implementation()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">GEngine</span>-&gt;<span class="title class_">AddOnScreenDebugMessage</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="title class_">FColor</span>::<span class="title class_">White</span>,<span class="title function_">TEXT</span>(<span class="string">&quot;C++ SpawnText_Implementation&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到函数会直接走到</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title class_">FName</span> NAME_UTPSGameInstance_SpawnText = <span class="title class_">FName</span>(<span class="title function_">TEXT</span>(<span class="string">&quot;SpawnText&quot;</span>));</span><br><span class="line"><span class="keyword">void</span> <span class="title class_">UTPSGameInstance</span>::<span class="title class_">SpawnText</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">ProcessEvent</span>(<span class="title class_">FindFunctionChecked</span>(NAME_UTPSGameInstance_SpawnText),<span class="variable constant_">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是通过FindFunctionChecked查找FuncMap里面的函数，就可以找到之前覆盖的LuaFunction，这样就调用到对应的execCallLua和execScriptCallLua 进而调到lua的里面覆写的函数。</p>
<h2 id="Lua调用C-UFuncition函数流程"><a href="#Lua调用C-UFuncition函数流程" class="headerlink" title="Lua调用C++UFuncition函数流程"></a>Lua调用C++UFuncition函数流程</h2><p>创建Class的Matetable的时候会把C++的Class_Index函数与__index绑定</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">luaL_newmetatable</span>(L, <span class="title class_">MetatableName</span>);</span><br><span class="line"><span class="title function_">lua_pushstring</span>(L, <span class="string">&quot;__index&quot;</span>);</span><br><span class="line"><span class="title function_">lua_pushcfunction</span>(L, <span class="title class_">Class</span>_Index);</span><br><span class="line"><span class="title function_">lua_rawset</span>(L, -<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>因此当lua调用函数的时候发现没有对应的对象就会触发__index，因此下面我们就从C++的Class_Index函数函数开始分析：</p>
<p>下面是Class_Index函数：</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line">int32 <span class="title class_">Class</span>_Index(lua_State *L)</span><br><span class="line">&#123;</span><br><span class="line"> int size= <span class="title function_">lua_gettop</span>(L);</span><br><span class="line"> <span class="title class_">GetField</span>(L);</span><br><span class="line"></span><br><span class="line"> auto <span class="title class_">Ptr</span> = <span class="title function_">lua_touserdata</span>(L, -<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span> (!<span class="title class_">Ptr</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> auto <span class="title class_">Property</span> = static_cast&lt;<span class="title class_">TSharedPtr</span>&lt;<span class="title class_">UnLua</span>::<span class="title class_">ITypeOps</span>&gt;*&gt;(<span class="title class_">Ptr</span>);</span><br><span class="line"> <span class="keyword">if</span> (!<span class="title class_">Property</span>-&gt;<span class="title class_">IsValid</span>())</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"> auto <span class="title class_">Self</span> = <span class="title class_">GetCppInstance</span>(L, <span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span> (!<span class="title class_">Self</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="title class_">UnLua</span>::<span class="title class_">LowLevel</span>::<span class="title class_">IsReleasedPtr</span>(<span class="title class_">Self</span>))</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">luaL_error</span>(L, <span class="title function_">TCHAR_TO_UTF8</span>(*<span class="title class_">FString</span>::<span class="title class_">Printf</span>(<span class="title function_">TEXT</span>(<span class="string">&quot;attempt to read property &#x27;%s&#x27; on released object&quot;</span>), *(*<span class="title class_">Property</span>)-&gt;<span class="title class_">GetName</span>())));</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!<span class="title class_">UnLua</span>::<span class="title class_">LowLevel</span>::<span class="title class_">CheckPropertyOwner</span>(L, (*<span class="title class_">Property</span>).<span class="title class_">Get</span>(), <span class="title class_">Self</span>))</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    (*<span class="title class_">Property</span>)-&gt;<span class="title class_">ReadValue</span>_InContainer(L, <span class="title class_">Self</span>, <span class="literal">false</span>);</span><br><span class="line"> <span class="title function_">lua_remove</span>(L, -<span class="number">2</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当触发Class_Index函数的时候栈是什么样的呢，在对GetField函数分析可以得出大概如下：<br><img src="/2024/04/14/Unlua%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image.png" alt="alt text"></p>
<p>其中包含对应的Class的和变量名称或者函数名称。</p>
<p>对于注册绑定的功能位于GetField函数里面，接下来分析下该函数</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">FORCEINLINE</span> <span class="keyword">static</span> int32 <span class="title class_">GetField</span>(lua_State* L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">lua_getmetatable</span>(L, <span class="number">1</span>); <span class="comment">//获取栈底的matetable放入栈顶</span></span><br><span class="line">    <span class="title function_">lua_pushvalue</span>(L, <span class="number">2</span>);   <span class="comment">//获取栈底往上数第二的元素放到栈顶</span></span><br><span class="line">    int32 <span class="title class_">Type</span> = <span class="title function_">lua_rawget</span>(L, -<span class="number">2</span>); <span class="comment">//在matetable查找栈顶的key，并移除栈顶将查找到的对象放入栈顶，没找到的话此时栈顶值为nil </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Type</span> == <span class="variable constant_">LUA_TNIL</span>) <span class="comment">//表示在matetable没有找到key的value，则表示不存在</span></span><br><span class="line">        <span class="title class_">GetFieldInternal</span>(L); </span><br><span class="line">    <span class="title function_">lua_remove</span>(L, -<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来进入到GetFieldInternal(L);</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title class_">GetFieldInternal</span>(lua_State* L) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">lua_pop</span>(L, <span class="number">1</span>);  <span class="comment">//把栈顶的nil弹出来</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">lua_pushstring</span>(L, <span class="string">&quot;__name&quot;</span>);  <span class="comment">//插入__name到栈顶</span></span><br><span class="line">    auto <span class="title class_">Type</span> = <span class="title function_">lua_rawget</span>(L, -<span class="number">2</span>); <span class="comment">//然后在前面的inst里面查找__name并加入到栈顶</span></span><br><span class="line">    <span class="title function_">check</span>(<span class="title class_">Type</span> == <span class="variable constant_">LUA_TSTRING</span>);   <span class="comment">//检查是否字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> char* <span class="title class_">ClassName</span> = <span class="title function_">lua_tostring</span>(L, -<span class="number">1</span>);  <span class="comment">// 获取栈顶的的字符串</span></span><br><span class="line">    <span class="keyword">const</span> char* <span class="title class_">FieldName</span> = <span class="title function_">lua_tostring</span>(L, <span class="number">2</span>);   <span class="comment">// 获取栈底第二的Name</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">lua_pop</span>(L, <span class="number">1</span>); <span class="comment">// 弹出类名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> refactor</span></span><br><span class="line">    <span class="keyword">const</span> auto <span class="title class_">Registry</span> = <span class="title class_">UnLua</span>::<span class="title class_">FLuaEnv</span>::<span class="title class_">FindEnv</span>(L)-&gt;<span class="title class_">GetClassRegistry</span>(); <span class="comment">//类注册器</span></span><br><span class="line">    <span class="title class_">FClassDesc</span>* <span class="title class_">ClassDesc</span> = <span class="title class_">Registry</span>-&gt;<span class="title class_">Register</span>(<span class="title class_">ClassName</span>); <span class="comment">//获取注册的类</span></span><br><span class="line">    <span class="title class_">TSharedPtr</span>&lt;<span class="title class_">FFieldDesc</span>&gt; <span class="title class_">Field</span> = <span class="title class_">ClassDesc</span>-&gt;<span class="title class_">RegisterField</span>(<span class="title class_">FieldName</span>, <span class="title class_">ClassDesc</span>); <span class="comment">//生成注册信息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Field</span> &amp;&amp; <span class="title class_">Field</span>-&gt;<span class="title class_">IsValid</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        bool bCached = <span class="literal">false</span>;</span><br><span class="line">        bool bInherited = <span class="title class_">Field</span>-&gt;<span class="title class_">IsInherited</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//bInherited   删除一些代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!bCached)  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title class_">PushField</span>(L, <span class="title class_">Field</span>);                <span class="comment">// Property / closure</span></span><br><span class="line">            <span class="title function_">lua_pushvalue</span>(L, <span class="number">2</span>);                <span class="comment">// key</span></span><br><span class="line">            <span class="title function_">lua_pushvalue</span>(L, -<span class="number">2</span>);               <span class="comment">// Property / closure</span></span><br><span class="line">            <span class="title function_">lua_rawset</span>(L, -<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bInherited)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">lua_remove</span>(L, -<span class="number">2</span>);</span><br><span class="line">            <span class="title function_">lua_pushvalue</span>(L, <span class="number">2</span>);                <span class="comment">// key</span></span><br><span class="line">            <span class="title function_">lua_pushvalue</span>(L, -<span class="number">2</span>);               <span class="comment">// Property / closure</span></span><br><span class="line">            <span class="title function_">lua_rawset</span>(L, -<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">ClassDesc</span>-&gt;<span class="title class_">IsClass</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">luaL_getmetatable</span>(L, <span class="string">&quot;UClass&quot;</span>);</span><br><span class="line">            <span class="title function_">lua_pushvalue</span>(L, <span class="number">2</span>);                <span class="comment">// push key</span></span><br><span class="line">            <span class="title function_">lua_rawget</span>(L, -<span class="number">2</span>);</span><br><span class="line">            <span class="title function_">lua_remove</span>(L, -<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">lua_pushnil</span>(L);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面着重对下面这个代码的栈分析一下：</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!bCached)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="title class_">PushField</span>(L, <span class="title class_">Field</span>);                <span class="comment">// Property / closure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始的栈是这样的<br><img src="/2024/04/14/Unlua%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image.png" alt="alt text"><br>看到 PushField(L, Field);里面的注册函数部分</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title class_">FObjectRegistry</span>::<span class="title class_">Push</span>(lua_State* L, <span class="title class_">TSharedPtr</span>&lt;T&gt; <span class="title class_">Ptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> auto <span class="title class_">Userdata</span> = <span class="title function_">lua_newuserdata</span>(L, <span class="title function_">sizeof</span>(<span class="title class_">TSharedPtr</span>&lt;T&gt;));</span><br><span class="line">    <span class="title function_">luaL_getmetatable</span>(L, <span class="string">&quot;TSharedPtr&quot;</span>);</span><br><span class="line">    <span class="title function_">lua_setmetatable</span>(L, -<span class="number">2</span>);</span><br><span class="line">    <span class="title function_">new</span>(<span class="title class_">Userdata</span>) <span class="title class_">TSharedPtr</span>&lt;T&gt;(<span class="title class_">Ptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/14/Unlua%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image3.png" alt="alt text"></p>
<p>最终栈顶是一个TSharedPtr<T>的userdata，接下来继续看PushField函数</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">Function</span>-&gt;<span class="title class_">IsLatentFunction</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">lua_pushcclosure</span>(L, <span class="title class_">Class</span>_CallLatentFunction, <span class="number">1</span>);   <span class="comment">// closure</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">lua_pushcclosure</span>(L, <span class="title class_">Class</span>_CallUFunction, <span class="number">1</span>);        <span class="comment">// closure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一部分是表示将一个C++函数和一个upvalue作为一个闭包推入栈顶，并从栈中弹出upvalue</p>
<p><img src="/2024/04/14/Unlua%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image-1.png" alt="alt text"></p>
<p>现在回到GetFieldInternal函数</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!bCached)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">PushField</span>(L, <span class="title class_">Field</span>);                <span class="comment">// Property / closure</span></span><br><span class="line">    <span class="title function_">lua_pushvalue</span>(L, <span class="number">2</span>);                <span class="comment">// 把Name拷贝一份到栈顶，closure的index成了-2</span></span><br><span class="line">    <span class="title function_">lua_pushvalue</span>(L, -<span class="number">2</span>);               <span class="comment">//把closure拷贝一份到栈顶</span></span><br><span class="line">    <span class="title function_">lua_rawset</span>(L, -<span class="number">4</span>);                  <span class="comment">// 把-1和-2号位置的设置到-4号位置，然后出栈-1和-2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完之后栈里面又剩下Inst和Name，后面执行这个清理栈</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">lua_remove</span>(L, -<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>接下来是调用的步骤：<br>前面已经看到对于非延迟的函数其会调用的Class_CallUFunction函数:</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line">int32 <span class="title class_">Class</span>_CallUFunction(lua_State *L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//!!!Fix!!!</span></span><br><span class="line">    <span class="comment">//delete desc when is not valid</span></span><br><span class="line">    auto&amp; <span class="title class_">Env</span> = <span class="title class_">UnLua</span>::<span class="title class_">FLuaEnv</span>::<span class="title class_">FindEnvChecked</span>(L);</span><br><span class="line">    auto <span class="title class_">Function</span> = <span class="title class_">Env</span>.<span class="title class_">GetObjectRegistry</span>()-&gt;<span class="title class_">Get</span>&lt;<span class="title class_">FFunctionDesc</span>&gt;(L, <span class="title function_">lua_upvalueindex</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Function</span>-&gt;<span class="title class_">IsValid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">UE_LOG</span>(<span class="title class_">LogUnLua</span>, <span class="title class_">Log</span>, <span class="title function_">TEXT</span>(<span class="string">&quot;%s: Invalid function descriptor!&quot;</span>), <span class="title function_">ANSI_TO_TCHAR</span>(__FUNCTION__));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int32 <span class="title class_">NumParams</span> = <span class="title function_">lua_gettop</span>(L);</span><br><span class="line">    int32 <span class="title class_">NumResults</span> = <span class="title class_">Function</span>-&gt;<span class="title class_">CallUE</span>(L, <span class="title class_">NumParams</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">NumResults</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的重点是lua_upvalueindex(1)获取到upvalue，从而获取到UserData转成FuncDesc，Function-&gt;CallUE(L, NumParams);这个就是实际调用到C++函数并提取lua传递过来的参数赋值给C++函数的地方，<br><img src="/2024/04/14/Unlua%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image-2.png" alt="调用栈"></p>
<h2 id="静态到出C-到Lua"><a href="#静态到出C-到Lua" class="headerlink" title="静态到出C++到Lua"></a>静态到出C++到Lua</h2><p>LuaEvn初始化的时候就会导出</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line">auto <span class="title class_">ExportedNonReflectedClasses</span> = <span class="title class_">GetExportedNonReflectedClasses</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> auto&amp; <span class="title class_">Pair</span> : <span class="title class_">ExportedNonReflectedClasses</span>)</span><br><span class="line">    <span class="title class_">Pair</span>.<span class="property">Value</span>-&gt;<span class="title class_">Register</span>(L);</span><br></pre></td></tr></table></figure>

<p>下面就是静态注册的过程，首先创建ClassName对应的metatable</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"> <span class="title function_">luaL_newmetatable</span>(L, <span class="title class_">ClassName</span>.<span class="title class_">Get</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="title class_">SuperClassName</span>.<span class="title class_">IsEmpty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">lua_pushstring</span>(L, <span class="string">&quot;Super&quot;</span>);</span><br><span class="line">    <span class="title class_">Type</span> = <span class="title function_">luaL_getmetatable</span>(L, <span class="title function_">TCHAR_TO_UTF8</span>(*<span class="title class_">SuperClassName</span>));</span><br><span class="line">    <span class="title function_">check</span>(<span class="title class_">Type</span> == <span class="variable constant_">LUA_TTABLE</span>);</span><br><span class="line">    <span class="title function_">lua_rawset</span>(L, -<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">lua_pushstring</span>(L, <span class="string">&quot;__index&quot;</span>);</span><br><span class="line"><span class="title function_">lua_pushvalue</span>(L, -<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Properties</span>.<span class="title class_">Num</span>() &gt; <span class="number">0</span> || !<span class="title class_">SuperClassName</span>.<span class="title class_">IsEmpty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">lua_pushcclosure</span>(L, <span class="title class_">UnLua</span>::<span class="title class_">Index</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">lua_rawset</span>(L, -<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">lua_pushstring</span>(L, <span class="string">&quot;__newindex&quot;</span>);</span><br><span class="line"><span class="title function_">lua_pushvalue</span>(L, -<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Properties</span>.<span class="title class_">Num</span>() &gt; <span class="number">0</span> || !<span class="title class_">SuperClassName</span>.<span class="title class_">IsEmpty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">lua_pushcclosure</span>(L, <span class="title class_">UnLua</span>::<span class="title class_">NewIndex</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">lua_rawset</span>(L, -<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">lua_pushvalue</span>(L, -<span class="number">1</span>);                    <span class="comment">// set metatable to self</span></span><br><span class="line"><span class="title function_">lua_setmetatable</span>(L, -<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>然后就开始注册成员函数和成员变量</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> auto&amp; <span class="title class_">Property</span> : <span class="title class_">Properties</span>)</span><br><span class="line">    <span class="title class_">Property</span>-&gt;<span class="title class_">Register</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> auto&amp; <span class="title class_">MemberFunc</span> : <span class="title class_">Functions</span>)</span><br><span class="line">    <span class="title class_">MemberFunc</span>-&gt;<span class="title class_">Register</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> auto&amp; <span class="title class_">Func</span> : <span class="title class_">GlueFunctions</span>)</span><br><span class="line">    <span class="title class_">Func</span>-&gt;<span class="title class_">Register</span>(L);</span><br></pre></td></tr></table></figure>

<p>最后把这个注册的matetable写入到UE的表中</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">lua_getglobal</span>(L, <span class="string">&quot;UE&quot;</span>);</span><br><span class="line"><span class="title function_">lua_pushstring</span>(L, <span class="title class_">ClassName</span>.<span class="title class_">Get</span>());</span><br><span class="line"><span class="title function_">lua_pushvalue</span>(L, -<span class="number">3</span>);</span><br><span class="line"><span class="title function_">lua_rawset</span>(L, -<span class="number">3</span>);</span><br><span class="line"><span class="title function_">lua_pop</span>(L, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>成员函数是下面的注册方式</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_">lua_pushstring</span>(L, <span class="title function_">TCHAR_TO_UTF8</span>(*<span class="title class_">Name</span>));   <span class="comment">//函数名到栈顶</span></span><br><span class="line"><span class="title function_">lua_pushlightuserdata</span>(L, <span class="variable language_">this</span>);            <span class="comment">//导出函数对象指针到栈顶</span></span><br><span class="line"><span class="title function_">lua_pushcclosure</span>(L, <span class="title class_">InvokeFunction</span>, <span class="number">1</span>);    <span class="comment">//推一个闭包函数并把lightuserdata作为upvalue</span></span><br><span class="line"><span class="title function_">lua_rawset</span>(L, -<span class="number">3</span>);                         <span class="comment">//将Name和那个闭包作为key-value设置到matetable中</span></span><br></pre></td></tr></table></figure>

<h2 id="Lua调用静态导出的函数"><a href="#Lua调用静态导出的函数" class="headerlink" title="Lua调用静态导出的函数"></a>Lua调用静态导出的函数</h2><p>根据上面的就能看出来，函数调用的时候最终会调用到这个C闭包函数InvokeFunction</p>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title class_">IExportedFunction</span> *<span class="title class_">Func</span> = (<span class="title class_">IExportedFunction</span>*)<span class="title function_">lua_touserdata</span>(L, <span class="title function_">lua_upvalueindex</span>(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Func</span> ? <span class="title class_">Func</span>-&gt;<span class="title class_">Invoke</span>(L) : <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Unlua</tag>
      </tags>
  </entry>
  <entry>
    <title>示例文章</title>
    <url>/2024/04/10/%E7%A4%BA%E4%BE%8B%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例化一个单例类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FSingletonTest</span> : public <span class="title class_">FSingleton</span>&lt;<span class="title class_">FSingletonTest</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight js"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建单例基类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">template&lt;typename <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="attr">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="title class_">Type</span>* m_pInstance;   <span class="comment">//当然也可以采用智能指针包裹 TShharedPtr&lt;Type&gt; m_pInstance</span></span><br><span class="line"></span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="title class_">FSingleton</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        m_pInstance = static_cast&lt;<span class="title class_">ReturnType</span>&gt;(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~<span class="title class_">FSingleton</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        m_pInstance=nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual <span class="keyword">void</span> <span class="title class_">InitSingleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    virtual <span class="keyword">void</span> <span class="title class_">ReleasePtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pInstance != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_pInstance;</span><br><span class="line">        &#125;</span><br><span class="line">        m_pInstance = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title class_">Type</span>* <span class="title class_">CreateInstance</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pInstance == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pInstance = <span class="keyword">new</span> <span class="title class_">Type</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title class_">Type</span>&amp; <span class="title class_">GetInstance</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title class_">Type</span>* <span class="title class_">GetInstancePtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> bool <span class="title class_">IsValid</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_pInstance != nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>创建文章</tag>
      </tags>
  </entry>
</search>
